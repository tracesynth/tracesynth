RISCV "Risc V partial order model"

(*****************************************)
(* The RISCV Instruction set manual v2.3 *)
(*****************************************)

(***************)
(* Definitions *)
(***************)

(* Define ppo *)
(*****************************************)
(* The RISCV Instruction set manual v2.3 *)
(*****************************************)

(* Compute coherence relation *)
(*"Generate co's"*)(*deheng commented this line (to merge into one file)*)

(* generates possible co's, optimized version *)

(* co observations in test *)
let invrf = rf^-1

let obsco =
  let ww = po-loc & (W * W)
  and rw = rf ; (po-loc & (R * W))
  and wr = ((po-loc & (W * R)) ; invrf) \ id
  and rr = (rf ; (po-loc & (R * R)) ; invrf) \ id in
  (ww|rw|wr|rr)

(* The following applies to C only, where RMW is both R and W *)
let rmwco =
  let _RMW = R & W in
  rf & (W * _RMW) (* co observation by atomicity *)

let cobase = obsco|rmwco|co0

(* Catch uniproc violations early *)
acyclic cobase as ConsCo

(*Cross*) (*deheng commented this line (to merge into one file)*)
(* Utilities for combining co's *)

(* Compute linearisations per locations *)
let co_locs (pco,wss) =
  let rec do_locs wss = match wss with
  || {} -> {}
  || ws ++ wss ->
      linearisations(ws,pco) ++ do_locs(wss)
  end in do_locs(wss)

(* Cross product linearisations *)
let cross =
  let rec do_cross (k,ys,oss) = match oss with
  || {} -> ys ++ k
  || os ++ oss ->
       let rec call_rec (k,os) = match os with
       || {} -> k
       || o ++ os ->
           call_rec (do_cross (k,o | ys,oss),os)
       end in
       call_rec (k,os)
  end in
  fun oss -> do_cross ({},0,oss)

(* Generate co's that extend partial order pco *)
let generate_orders(s,pco) = cross (co_locs (pco,partition s))
let generate_cos(pco) = generate_orders(W,pco)


with co from generate_cos(cobase)
(* From now, co is a coherence order *)
let coi = co & int
let coe = co \ coi

(* Compute fr *)
let fr = (invrf ; co) \ id
let fri = fr & int
let fre = fr \ fri

show co,fr
(*************)
(* Utilities *)
(*************)

let fence.r.r = [R];fencerel(Fence.r.r);[R]
let fence.r.w = [R];fencerel(Fence.r.w);[W]
let fence.r.rw = [R];fencerel(Fence.r.rw);[M]
let fence.w.r = [W];fencerel(Fence.w.r);[R]
let fence.w.w = [W];fencerel(Fence.w.w);[W]
let fence.w.rw = [W];fencerel(Fence.w.rw);[M]
let fence.rw.r = [M];fencerel(Fence.rw.r);[R]
let fence.rw.w = [M];fencerel(Fence.rw.w);[W]
let fence.rw.rw = [M];fencerel(Fence.rw.rw);[M]
let fence.tso =
  let f = fencerel(Fence.tso) in
  ([W];f;[W]) | ([R];f;[M])

let fence =
  fence.r.r | fence.r.w | fence.r.rw |
  fence.w.r | fence.w.w | fence.w.rw |
  fence.rw.r | fence.rw.w | fence.rw.rw |
  fence.tso


let po-loc-no-w = po-loc \ (po-loc?;[W];po-loc)
let rsw = rf^-1;rf
let AcqRel = AcqRel|Sc (* Compat *)
let AQ = (Acq|AcqRel)
and RL = (Rel|AcqRel)
let AMO = try AMO with (R & W) (* Compat *)
let RCsc = (Acq|Rel|AcqRel) & (AMO|X)
(*************)
(* ppo rules *)
(*************)
let XLr = (X & R) \ AMO
let XSc = (X & W) \ AMO

(* Overlapping-Address Orderings *)
let r1 = [M];po-loc;[W]
and r2 = ([R];po-loc-no-w;[R]) \ rsw
and r3 = [AMO|X];rfi;[R]
(* Explicit Synchronization *)
and r4 = fence
and r5 = [AQ];po;[M]
and r6 = [M];po;[RL]
and r7 = [RCsc];po;[RCsc]
and r8 = rmw
(* Syntactic Dependencies *)
and r9 = [M];addr;[M]
and r10 = [M];data;[W]
and r11 = [M];ctrl;[W]
(* Pipeline Dependencies *)
and r12 = [M];(addr|data);[W];rfi;[R]
and r13 = [M];addr;[M];po;[W]
and r14 = [W];fencerel(Fence.r.rw);[W]
and r15 = [R];fencerel(Fence.rw.w);[R]
and r16= [R];fencerel(Fence.w.w);[W]
and r17 = [W];fencerel(Fence.rw.w);[R]
and r18 = [W];fencerel(Fence.r.rw);[R]
and r19 = [R];fencerel(Fence.w.r);[R]
and r20 = [W];fencerel(Fence.tso);[R]
and r21 = [W];fencerel(Fence.r.r);[R]
and r22 = [R];po;[XLr]
and r23 = [XLr];po;[W]
and r24 = [RL];po;[W]
and r25 = [W];po;[AQ]
and r26 = [AMO];po;[AMO]
and r27 = [R];fencerel(Fence.w.rw);[R]
and r28 = [R];fencerel(Fence.w.rw);[R]
and r29= [R];fencerel(Fence.rw.r);[W]
and r30 = [R];fencerel(Fence.w.r);[W]
and r31 = [W];fencerel(Fence.rw.r);[W]
and r32 = [W];fencerel(Fence.r.r);[W]
and r33 = [W];fencerel(Fence.w.r);[W]
and r34 = [XLr];po;[R]
and r35 = [AMO];po;[W]
and r36 = [W];po;[XLr]
and r37 = [W];po;[AMO]

let ppo =
  r1
| r2
| r3
| r4
| r5
| r6
| r7
| r8
| r9
| r10
| r11
| r12
| r13
| r15
| r16
| r17
| r18
| r19
| r20
| r21
| r22
| r23
| r24
| r25
| r26
| r27
| r28
| r29
| r30
| r31
| r32
| r33
| r34
| r35
| r36
| r37






(**********)
(* Axioms *)
(**********)

(* Sc per location *)
acyclic co|rf|fr|po-loc as Coherence

(* Main model axiom *)
acyclic co|rfe|fr|ppo as Model

(* Atomicity axiom *)
empty rmw & (fre;coe) as Atomic
